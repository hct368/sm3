; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\sm3\sm3.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@FOLEAJAI@?6?$CF08x?5?$CF08x?5?$CF08x?5?$CF08x?$AA@ ; `string'
PUBLIC	??_C@_05ECIELPFL@?$CF08x?5?$AA@			; `string'
PUBLIC	_SM3_Transform
EXTRN	_printf:PROC
;	COMDAT ??_C@_0BF@FOLEAJAI@?6?$CF08x?5?$CF08x?5?$CF08x?5?$CF08x?$AA@
; File c:\hub\sm3\sm3.c
CONST	SEGMENT
??_C@_0BF@FOLEAJAI@?6?$CF08x?5?$CF08x?5?$CF08x?5?$CF08x?$AA@ DB 0aH, '%08'
	DB	'x %08x %08x %08x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ECIELPFL@?$CF08x?5?$AA@
CONST	SEGMENT
??_C@_05ECIELPFL@?$CF08x?5?$AA@ DB '%08x ', 00H		; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT _SM3_Transform
_TEXT	SEGMENT
_w$ = -304						; size = 272
_s$ = -32						; size = 32
tv352 = 8						; size = 4
_ctx$ = 8						; size = 4
_SM3_Transform PROC					; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H

; 46   :     uint32_t tt1, tt2, i, j, t, ss1, ss2, x, y;
; 47   :     uint32_t w[68], s[8];
; 48   : 
; 49   :     #define a s[0]
; 50   :     #define b s[1]
; 51   :     #define c s[2]
; 52   :     #define d s[3]
; 53   :     #define e s[4]
; 54   :     #define f s[5]
; 55   :     #define g s[6]
; 56   :     #define h s[7]
; 57   :     
; 58   :     // load state into local buffer
; 59   :     memcpy((uint8_t*)&s[0], (uint8_t*)&ctx->s.w[0], 8*4);

	mov	eax, DWORD PTR _ctx$[ebp]
	push	ebx
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+8]
	push	32					; 00000020H
	lea	edi, DWORD PTR _s$[ebp]
	pop	ecx
	mov	DWORD PTR tv352[ebp], esi
	rep movsb

; 60   :     
; 61   :     // load data in big endian format
; 62   :     for (i=0; i<16; i++) {

	xor	ecx, ecx
	add	eax, 40					; 00000028H
$LL14@SM3_Transf:

; 63   :       w[i] = SWAP32(ctx->buf.w[i]);

	mov	edx, DWORD PTR [eax]
	bswap	edx
	mov	DWORD PTR _w$[ebp+ecx*4], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LL14@SM3_Transf

; 64   :     }
; 65   : 
; 66   :     // expand message
; 67   :     for (i=16; i<68; i++) {

	push	52					; 00000034H
	lea	esi, DWORD PTR _w$[ebp]
	pop	edi
$LL11@SM3_Transf:

; 68   :       x = ROTL32(w[i- 3], 15);

	mov	eax, DWORD PTR [esi+52]

; 69   :       y = ROTL32(w[i-13],  7);

	mov	ecx, DWORD PTR [esi+12]
	rol	eax, 15					; 0000000fH

; 70   :       
; 71   :       x ^= w[i-16];
; 72   :       x ^= w[i- 9];

	xor	eax, DWORD PTR [esi+28]
	xor	eax, DWORD PTR [esi]
	rol	ecx, 7

; 73   :       y ^= w[i- 6];
; 74   :       
; 75   :       w[i] =  P1(x) ^ y; 

	mov	edx, eax
	rol	edx, 23					; 00000017H
	xor	ecx, edx
	mov	edx, eax
	rol	edx, 15					; 0000000fH
	xor	ecx, edx
	xor	ecx, DWORD PTR [esi+40]
	xor	ecx, eax

; 76   :       printf ("%08x ", w[i]);

	push	ecx
	push	OFFSET ??_C@_05ECIELPFL@?$CF08x?5?$AA@
	mov	DWORD PTR [esi+64], ecx
	call	_printf
	pop	ecx
	add	esi, 4
	dec	edi
	pop	ecx
	jne	SHORT $LL11@SM3_Transf

; 77   :     }
; 78   : 
; 79   :     // compression function
; 80   :     for (i=0; i<64; i++) {

	xor	ebx, ebx
$LL8@SM3_Transf:

; 81   :       t  = (i < 16) ? 0x79cc4519 : 0x7a879d8a;
; 82   :       
; 83   :       ss2 = ROTL32(a, 12);      

	mov	esi, DWORD PTR _s$[ebp]

; 84   :       ss1 = ROTL32(ss2 + e + ROTL32(t, i), 7);
; 85   :       ss2 ^= ss1;
; 86   :       
; 87   :       tt1 = d + ss2 + (w[i] ^ w[i+4]);

	mov	edi, DWORD PTR _w$[ebp+ebx*4+16]
	rol	esi, 12					; 0000000cH
	cmp	ebx, 16					; 00000010H
	sbb	eax, eax
	and	eax, -12277873				; ff44a78fH
	add	eax, 2055708042				; 7a879d8aH
	mov	cl, bl
	rol	eax, cl
	mov	ecx, DWORD PTR _w$[ebp+ebx*4]
	xor	edi, ecx
	add	edi, DWORD PTR _s$[ebp+12]
	add	eax, DWORD PTR _s$[ebp+16]

; 88   :       tt2 = h + ss1 + w[i];

	add	ecx, DWORD PTR _s$[ebp+28]
	add	eax, esi
	rol	eax, 7
	mov	edx, eax
	xor	edx, esi
	add	edx, edi
	add	ecx, eax

; 89   :       
; 90   :       if (i < 16) {

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN5@SM3_Transf

; 91   :         tt1 += F(a, b, c);

	mov	eax, DWORD PTR _s$[ebp+8]
	xor	eax, DWORD PTR _s$[ebp+4]
	xor	eax, DWORD PTR _s$[ebp]
	add	edx, eax

; 92   :         tt2 += F(e, f, g);

	mov	eax, DWORD PTR _s$[ebp+24]
	xor	eax, DWORD PTR _s$[ebp+20]
	xor	eax, DWORD PTR _s$[ebp+16]

; 93   :       } else {

	jmp	SHORT $LN25@SM3_Transf
$LN5@SM3_Transf:

; 94   :         tt1 += FF(a, b, c);

	mov	eax, DWORD PTR _s$[ebp+4]
	or	eax, DWORD PTR _s$[ebp]
	mov	esi, DWORD PTR _s$[ebp+4]
	and	eax, DWORD PTR _s$[ebp+8]
	and	esi, DWORD PTR _s$[ebp]
	or	eax, esi
	add	edx, eax

; 95   :         tt2 += GG(e, f, g);       

	mov	eax, DWORD PTR _s$[ebp+24]
	xor	eax, DWORD PTR _s$[ebp+20]
	and	eax, DWORD PTR _s$[ebp+16]
	xor	eax, DWORD PTR _s$[ebp+24]
$LN25@SM3_Transf:

; 96   :       }
; 97   :       d = c;
; 98   :       c = ROTL32(b, 9);
; 99   :       b = a;
; 100  :       a = tt1;
; 101  :       h = g;

	mov	esi, DWORD PTR _s$[ebp+24]
	add	ecx, eax
	mov	eax, DWORD PTR _s$[ebp+8]
	mov	DWORD PTR _s$[ebp+28], esi

; 102  :       g = ROTL32(f, 19);

	mov	esi, DWORD PTR _s$[ebp+20]
	mov	DWORD PTR _s$[ebp+12], eax
	mov	eax, DWORD PTR _s$[ebp+4]

; 103  :       f = e;
; 104  :       e = P0(tt2);  
; 105  :       printf ("\n%08x %08x %08x %08x", a, b, c, d);

	push	DWORD PTR _s$[ebp+12]
	rol	eax, 9
	rol	esi, 19					; 00000013H
	mov	DWORD PTR _s$[ebp+24], esi
	mov	esi, DWORD PTR _s$[ebp+16]
	mov	DWORD PTR _s$[ebp+20], esi
	mov	DWORD PTR _s$[ebp+8], eax
	mov	eax, DWORD PTR _s$[ebp]
	push	DWORD PTR _s$[ebp+8]
	mov	esi, ecx
	rol	esi, 17					; 00000011H
	mov	edi, ecx
	push	eax
	rol	edi, 9
	xor	esi, edi
	push	edx
	xor	esi, ecx
	push	OFFSET ??_C@_0BF@FOLEAJAI@?6?$CF08x?5?$CF08x?5?$CF08x?5?$CF08x?$AA@
	mov	DWORD PTR _s$[ebp+4], eax
	mov	DWORD PTR _s$[ebp], edx
	mov	DWORD PTR _s$[ebp+16], esi
	call	_printf
	add	esp, 20					; 00000014H
	inc	ebx
	cmp	ebx, 64					; 00000040H
	jb	$LL8@SM3_Transf

; 106  :     }
; 107  :     
; 108  :     // Daviesâ€“Meyer idea for compression function
; 109  :     for (i=0; i<8; i++) {

	mov	eax, DWORD PTR tv352[ebp]
	pop	edi
	pop	esi
	xor	ecx, ecx
	pop	ebx
$LL3@SM3_Transf:

; 110  :       ctx->s.w[i] ^= s[i];

	mov	edx, DWORD PTR _s$[ebp+ecx*4]
	xor	DWORD PTR [eax], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 8
	jb	SHORT $LL3@SM3_Transf

; 111  :     }    
; 112  :     #undef a
; 113  :     #undef b
; 114  :     #undef c
; 115  :     #undef d
; 116  :     #undef e
; 117  :     #undef f
; 118  :     #undef g
; 119  :     #undef h
; 120  : }

	leave
	ret	0
_SM3_Transform ENDP
_TEXT	ENDS
PUBLIC	_SM3_Init
; Function compile flags: /Ogspy
;	COMDAT _SM3_Init
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_SM3_Init PROC						; COMDAT

; 128  :     ctx->s.w[0] = 0x7380166f;

	mov	eax, DWORD PTR _ctx$[esp-4]

; 129  :     ctx->s.w[1] = 0x4914b2b9;
; 130  :     ctx->s.w[2] = 0x172442d7;
; 131  :     ctx->s.w[3] = 0xda8a0600;
; 132  :     ctx->s.w[4] = 0xa96f30bc;
; 133  :     ctx->s.w[5] = 0x163138aa;
; 134  :     ctx->s.w[6] = 0xe38dee4d;
; 135  :     ctx->s.w[7] = 0xb0fb0e4e;
; 136  :     ctx->len    = 0;

	and	DWORD PTR [eax], 0
	and	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1937774191		; 7380166fH
	mov	DWORD PTR [eax+12], 1226093241		; 4914b2b9H
	mov	DWORD PTR [eax+16], 388252375		; 172442d7H
	mov	DWORD PTR [eax+20], -628488704		; da8a0600H
	mov	DWORD PTR [eax+24], -1452330820		; a96f30bcH
	mov	DWORD PTR [eax+28], 372324522		; 163138aaH
	mov	DWORD PTR [eax+32], -477237683		; e38dee4dH
	mov	DWORD PTR [eax+36], -1325724082		; b0fb0e4eH

; 137  : }

	ret	0
_SM3_Init ENDP
_TEXT	ENDS
PUBLIC	_SM3_Update
; Function compile flags: /Ogspy
;	COMDAT _SM3_Update
_TEXT	SEGMENT
_p$ = -4						; size = 4
_ctx$ = 8						; size = 4
_r$ = 12						; size = 4
_in$ = 12						; size = 4
_len$ = 16						; size = 4
_SM3_Update PROC					; COMDAT

; 144  : void SM3_Update (SM3_CTX *ctx, void *in, uint32_t len) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 145  :     uint8_t *p = (uint8_t*)in;

	mov	eax, DWORD PTR _in$[ebp]

; 146  :     uint32_t r, idx;
; 147  :     
; 148  :     // get buffer index
; 149  :     idx = ctx->len & SM3_CBLOCK - 1;
; 150  :     
; 151  :     // update length
; 152  :     ctx->len += len;

	mov	ecx, DWORD PTR _len$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	mov	eax, DWORD PTR [ebx]
	and	eax, 63					; 0000003fH
	add	DWORD PTR [ebx], ecx
	adc	DWORD PTR [ebx+4], 0

; 153  :     
; 154  :     while (len) {

	test	ecx, ecx
	je	SHORT $LN9@SM3_Update
	push	esi
	push	edi
$LL3@SM3_Update:

; 155  :       r = MIN(len, SM3_CBLOCK - idx);

	mov	edx, DWORD PTR _len$[ebp]
	push	64					; 00000040H
	pop	ecx
	sub	ecx, eax
	mov	DWORD PTR _r$[ebp], edx
	cmp	edx, ecx
	jb	SHORT $LN7@SM3_Update
	mov	DWORD PTR _r$[ebp], ecx
$LN7@SM3_Update:

; 156  :       memcpy (&ctx->buf.b[idx], p, r);

	mov	edx, DWORD PTR _r$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, edx

; 157  :       if ((idx + r) < SM3_CBLOCK) break;

	add	edx, eax
	lea	edi, DWORD PTR [ebx+eax+40]
	rep movsb
	cmp	edx, 64					; 00000040H
	jb	SHORT $LN12@SM3_Update

; 158  :       
; 159  :       SM3_Transform (ctx);

	push	ebx
	call	_SM3_Transform
	pop	ecx

; 160  :       len -= r;

	mov	ecx, DWORD PTR _r$[ebp]
	sub	DWORD PTR _len$[ebp], ecx

; 161  :       idx = 0;
; 162  :       p += r;

	add	DWORD PTR _p$[ebp], ecx
	xor	eax, eax
	cmp	DWORD PTR _len$[ebp], eax
	jne	SHORT $LL3@SM3_Update
$LN12@SM3_Update:
	pop	edi
	pop	esi
$LN9@SM3_Update:
	pop	ebx

; 163  :     }
; 164  : }

	leave
	ret	0
_SM3_Update ENDP
_TEXT	ENDS
PUBLIC	_SM3_Final
; Function compile flags: /Ogspy
;	COMDAT _SM3_Final
_TEXT	SEGMENT
_out$ = 8						; size = 4
_ctx$ = 12						; size = 4
_SM3_Final PROC						; COMDAT

; 172  : {

	push	ebx
	push	esi

; 173  :     int i;
; 174  :     
; 175  :     // see what length we have ere..
; 176  :     uint32_t len=ctx->len & SM3_CBLOCK - 1;

	mov	esi, DWORD PTR _ctx$[esp+4]
	mov	edx, DWORD PTR [esi]
	push	edi
	and	edx, 63					; 0000003fH

; 177  :     // fill remaining with zeros
; 178  :     memset (&ctx->buf.b[len], 0, SM3_CBLOCK - len);

	push	64					; 00000040H
	lea	ebx, DWORD PTR [edx+esi+40]
	pop	ecx
	sub	ecx, edx
	xor	al, al
	mov	edi, ebx
	rep stosb

; 179  :     // add the end bit
; 180  :     ctx->buf.b[len] = 0x80;

	mov	BYTE PTR [ebx], 128			; 00000080H

; 181  :     // if exceeding 56 bytes, transform it
; 182  :     if (len >= 56) {

	cmp	edx, 56					; 00000038H
	jb	SHORT $LN4@SM3_Final

; 183  :       SM3_Transform (ctx);

	push	esi
	call	_SM3_Transform
	pop	ecx

; 184  :       // clear buffer
; 185  :       memset (ctx->buf.b, 0, SM3_CBLOCK);

	push	64					; 00000040H
	lea	edi, DWORD PTR [esi+40]
	xor	al, al
	pop	ecx
	rep stosb
$LN4@SM3_Final:

; 186  :     }
; 187  :     // add total bits
; 188  :     ctx->buf.q[7] = SWAP64((uint64_t)ctx->len * 8);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	shld	ecx, eax, 3
	shl	eax, 3
	bswap	eax
	bswap	ecx

; 189  :     // compress
; 190  :     SM3_Transform(ctx);

	push	esi
	mov	DWORD PTR [esi+96], ecx
	mov	DWORD PTR [esi+100], eax
	call	_SM3_Transform
	pop	ecx

; 191  :     
; 192  :     // return result
; 193  :     for (i=0; i<SM3_LBLOCK; i++) {

	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+8]
$LL3@SM3_Final:

; 194  :       ((uint32_t*)out)[i] = SWAP32(ctx->s.w[i]);

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR _out$[esp+8]
	bswap	edx
	mov	DWORD PTR [esi+ecx*4], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 8
	jl	SHORT $LL3@SM3_Final

; 195  :     }
; 196  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_SM3_Final ENDP
_TEXT	ENDS
END
